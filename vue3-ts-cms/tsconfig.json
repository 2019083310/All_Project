{
  "compilerOptions": {
    // 我们的ts代码转成js代码是es5还是es6/es7...
    // 但是我们脚手架安装的时候使用的是babel在这就不用声明了
    "target": "esnext",
    // 指的是项目里使用的模块化方式，这里是esModule
    "module": "esnext",
    // ts代码在编译的时候是否做严格的检查:any类型
    "strict": true,
    // 如果有jsx的模板，那么最终转换成什么类型？是render函数还是其它，preserve是保持不变
    "jsx": "preserve",
    // 是否用辅助的引用
    "importHelpers": true,
    // 我们的模块的文件引入的查找方式是按照node中规定的文件查找方式.js  .json  .node
    "moduleResolution": "node",
    // skip跳出对node_modules中的第三方库的ts文件的编译
    "skipLibCheck": true,
    // 下面这两个都是用来说明在项目中既可以用esModule也可以用commonJs导入导出
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    // 编译ts是否生成source-map文件
    "sourceMap": true,
    // 我们在编译ts时候，都是按照当前目录下的路径
    "baseUrl": ".",
    // 根据webpack中的环境来编译对应的类型
    "types": ["webpack-env"],
    // 这个类似于webpack中的resolve.alias配置别名
    "paths": {
      "@/*": ["src/*"]
    },
    // 这个是用来说明ts中默认可以使用的类型，比如Proxy,dom,等等
    "lib": ["esnext", "dom", "dom.iterable", "scripthost"]
  },
  // 这个是用来说明对什么位置的ts代码转换js并打包
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "tests/**/*.ts", "tests/**/*.tsx"],
  // 这个就是忽略对第三方库的ts文件的编译打包，但是引入的第三方库的ts类型如果引用还是会打包那个类型ts代码
  "exclude": ["node_modules"]
}
